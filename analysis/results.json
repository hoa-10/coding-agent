{
    "dataset_info": {
        "X_train": {
            "original_shape": [
                15456,
                500,
                1
            ],
            "dtype": "float64",
            "processed_shape": [
                15456,
                500
            ]
        },
        "y_train": {
            "original_shape": [
                15456
            ],
            "dtype": "int32"
        },
        "X_valid": {
            "original_shape": [
                10304,
                500,
                1
            ],
            "dtype": "float64",
            "processed_shape": [
                10304,
                500
            ]
        },
        "y_valid": {
            "original_shape": [
                10304
            ],
            "dtype": "int32"
        },
        "X_scan": {
            "original_shape": [
                25761,
                500,
                1
            ],
            "dtype": "float64",
            "processed_shape": [
                25761,
                500
            ]
        },
        "X_in_corr": {
            "original_shape": [
                161,
                160,
                500
            ],
            "dtype": "float64"
        },
        "Xc": {
            "original_shape": [
                711,
                500
            ],
            "dtype": "float64"
        },
        "Xg": {
            "original_shape": [
                25049,
                500
            ],
            "dtype": "float64"
        },
        "m": {
            "original_shape": [
                1,
                500,
                1
            ],
            "dtype": "float64",
            "processed_shape": [
                1,
                500
            ]
        },
        "st": {
            "original_shape": [
                1,
                500,
                1
            ],
            "dtype": "float64",
            "processed_shape": [
                1,
                500
            ]
        },
        "label_distributions": {
            "y_train": {
                "0": {
                    "count": 15029,
                    "percentage": 97.24,
                    "meaning": "Good"
                },
                "1": {
                    "count": 427,
                    "percentage": 2.76,
                    "meaning": "Defect"
                }
            },
            "y_valid": {
                "0": {
                    "count": 10020,
                    "percentage": 97.24,
                    "meaning": "Good"
                },
                "1": {
                    "count": 284,
                    "percentage": 2.76,
                    "meaning": "Defect"
                }
            }
        }
    },
    "extracted_feature_statistics": {
        "X_train": {
            "mean": 1.0792294594229251e-14,
            "std": 0.9999998900751302,
            "min": -7.056056911884795,
            "max": 7.280649669227083,
            "median": -0.025842401527920188
        },
        "Xc": {
            "mean": 0.08864829138949448,
            "std": 1.3767955725040784,
            "min": -4.726041908504586,
            "max": 4.822827732061161,
            "median": 0.1312220746489563
        },
        "Xg": {
            "mean": -0.001058808819324094,
            "std": 0.987532718260007,
            "min": -7.0660073514046795,
            "max": 7.280649669227083,
            "median": -0.029049972368833544
        },
        "X_scan": {
            "mean": 0.0014492367025431413,
            "std": 1.0004328115994363,
            "min": -7.0660073514046795,
            "max": 7.280649669227083,
            "median": -0.025379125721112148
        }
    },
    "preprocessing_steps": "The dataset includes 'm' (mean) and 'st' (standard deviation) arrays, which are typically used for Z-score normalization. This normalization, following the formula `normalized_signal = (raw_signal - m) / st`, is crucial for standardizing input data for machine learning models and should be applied consistently across training, validation, and inference.",
    "summary_findings_recommendations": {
        "findings": [
            "Significant class imbalance detected: Training set has 2.76% defect samples, validation set has 2.76% defect samples. The 'Defect' class (label 1) is considerably underrepresented.",
            "The 'Average PECT Signals: Good vs. Defect' plot reveals clear characteristic differences:",
            "- **Initial Peak Amplitude:** Defect signals (Xc) tend to have a noticeably lower peak amplitude compared to good signals (Xg) at early time points.",
            "- **Decay Rate:** Defect signals exhibit a faster decay, dropping to lower voltage values more quickly than good signals.",
            "- **Overall Waveform Shape:** The entire waveform of defect signals appears 'damped' or 'compressed' vertically compared to good signals, indicating a weaker or altered electromagnetic response.",
            "The `X_in_corr` array, structured as a 2D spatial grid (rows x columns x time_points), is exceptionally valuable for visualizing the spatial extent and location of defects. It allows mapping derived signal features (e.g., average amplitude, defect classification scores) back to a physical image of the inspected surface."
        ],
        "recommendations": [
            "To address the class imbalance, consider using techniques such as: class weighting in loss functions (e.g., `class_weight` in TensorFlow/Keras, `weight` parameter in PyTorch's `CrossEntropyLoss`), oversampling the minority class (e.g., SMOTE), or undersampling the majority class. Evaluate models using metrics robust to imbalance like F1-score, Precision, Recall, or AUC-ROC instead of just accuracy.",
            "The distinct differences in signal shape (amplitude, decay rate) between good and defect regions suggest that these features are highly discriminative. Models capable of learning temporal patterns, such as Convolutional Neural Networks (CNNs) or Recurrent Neural Networks (RNNs) for time-series classification, would be well-suited. Feature engineering based on these observed characteristics (e.g., peak amplitude, time-to-peak, integrated signal strength, decay coefficients) could also be highly effective for simpler models.",
            "Normalization using the provided 'm' (mean) and 'st' (standard deviation) arrays is strongly recommended as a preprocessing step. This will scale the input features consistently, which is crucial for the stability and performance of most machine learning algorithms, especially neural networks. Apply `(signal - m) / st` to `X_train`, `X_valid`, and `X_scan`.",
            "For post-processing and reporting, consider projecting features or model predictions from `X_in_corr` onto a 2D map to visualize defect regions on the scanned surface. This is critical for practical NDT applications."
        ]
    },
    "plot_paths": [
        "analysis\\figures\\average_signals_good_vs_defect.png",
        "analysis\\figures\\example_signals_good_vs_defect.png"
    ]
}