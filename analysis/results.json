{
    "dataset_info": {
        "X_train": {
            "shape": [
                15456,
                500,
                1
            ],
            "dtype": "float64"
        },
        "y_train": {
            "shape": [
                15456
            ],
            "dtype": "int32"
        },
        "X_valid": {
            "shape": [
                10304,
                500,
                1
            ],
            "dtype": "float64"
        },
        "y_valid": {
            "shape": [
                10304
            ],
            "dtype": "int32"
        },
        "X_scan": {
            "shape": [
                25761,
                500,
                1
            ],
            "dtype": "float64"
        },
        "X_in_corr": {
            "shape": [
                161,
                160,
                500
            ],
            "dtype": "float64"
        },
        "Xc": {
            "shape": [
                711,
                500
            ],
            "dtype": "float64"
        },
        "Xg": {
            "shape": [
                25049,
                500
            ],
            "dtype": "float64"
        },
        "m": {
            "shape": [
                1,
                500,
                1
            ],
            "dtype": "float64"
        },
        "st": {
            "shape": [
                1,
                500,
                1
            ],
            "dtype": "float64"
        }
    },
    "label_distributions": {
        "y_train": {
            "counts": {
                "0": 15029,
                "1": 427
            },
            "total": 15456,
            "percentage": {
                "0": "97.24%",
                "1": "2.76%"
            }
        },
        "y_valid": {
            "counts": {
                "0": 10020,
                "1": 284
            },
            "total": 10304,
            "percentage": {
                "0": "97.24%",
                "1": "2.76%"
            }
        }
    },
    "global_signal_statistics": {
        "X_train": {
            "mean": 1.0792294594229251e-14,
            "std": 0.9999998900751302,
            "min": -7.056056911884795,
            "max": 7.280649669227083,
            "median": -0.025842401527920188
        },
        "X_scan": {
            "mean": 0.0014492367025431413,
            "std": 1.0004328115994363,
            "min": -7.0660073514046795,
            "max": 7.280649669227083,
            "median": -0.025379125721112148
        },
        "Xc": {
            "mean": 0.08864829138949448,
            "std": 1.3767955725040784,
            "min": -4.726041908504586,
            "max": 4.822827732061161,
            "median": 0.1312220746489563
        },
        "Xg": {
            "mean": -0.001058808819324094,
            "std": 0.987532718260007,
            "min": -7.0660073514046795,
            "max": 7.280649669227083,
            "median": -0.029049972368833544
        }
    },
    "preprocessing_info": {
        "normalization_mean_shape": [
            1,
            500,
            1
        ],
        "normalization_mean_sample": [
            -0.7433822213230057,
            -0.7519376250400216,
            -0.753648132752122,
            -0.7552037014767782,
            -0.7566605263062575,
            "...",
            -0.7360121531086897,
            -0.7393838403047048,
            -0.7424398252470865,
            -0.7451683530063311,
            -0.7476368105698711
        ],
        "normalization_std_shape": [
            1,
            500,
            1
        ],
        "normalization_std_sample": [
            0.006309938449197285,
            0.006334069626309095,
            0.006327759009527499,
            0.0063727489446042535,
            0.006313032917567672,
            "...",
            0.006255190126724827,
            0.006334819264467224,
            0.006320831687810404,
            0.0063516638912508635,
            0.0063847962890038355
        ],
        "description": "The 'm' and 'st' arrays are provided for z-score normalization (standardization) of the signals. Each array contains 500 values, corresponding to the mean and standard deviation for each of the 500 time points across a reference dataset (e.g., the entire training set or a large good-signal population). Signals should be normalized as `X_normalized = (X - m) / st`. Their shape (1, 500, 1) is designed for convenient broadcasting when applied to signal arrays of shape (N, 500, 1)."
    },
    "summary_and_recommendations": {
        "findings": [
            "**Class Imbalance**: Significant class imbalance detected in training data. Good samples: 15029 (97.24%), Defect samples: 427 (2.76%). The ratio of Good to Defect samples is approximately 35.20:1.",
            "**Signal Characteristics**: The 'Average PECT Signal: Good vs. Defect' plots clearly show distinct differences between signal waveforms from good and defective regions.Specifically, defect signals tend to exhibit:  - A notably lower peak amplitude compared to good signals.  - A delayed time-to-peak or a broader peak.  - A slower decay rate, especially observed in the latter half of the signal (after the main peak).  - Potential shifts in the overall baseline or a prolonged recovery time."
        ],
        "recommendations": [
            "**Normalization**: It is highly recommended to normalize (standardize) the input signals using the provided 'm' and 'st' arrays. This operation `(X - m) / st` should be applied consistently to X_train, X_valid, and X_scan. Normalization helps stabilize model training and improves performance for most machine learning algorithms.",
            "**Address Class Imbalance**: Given the detected class imbalance, consider strategies such as:   - **Resampling**: Oversampling the minority class (e.g., using SMOTE or simple duplication) or undersampling the majority class.   - **Weighted Loss Functions**: Using a loss function that penalizes misclassifications of the minority class more heavily.   - **Ensemble Methods**: Bagging or boosting techniques designed for imbalanced datasets.",
            "**Feature Engineering/Model Choice**:   - The distinct waveform differences suggest that features like peak amplitude, time-to-peak, decay characteristics, and area under the curve would be highly discriminative.   - Deep learning models (e.g., 1D Convolutional Neural Networks (CNNs) or Recurrent Neural Networks (RNNs) like LSTMs) are well-suited for learning these complex temporal features directly from the raw signals without explicit feature engineering.   - Frequency domain analysis (e.g., using Fast Fourier Transform) could also reveal discriminative features related to signal damping or resonance shifts.",
            "**Validation Strategy**: Utilize the provided X_valid and y_valid sets for objective model performance evaluation and hyperparameter tuning to avoid overfitting to the training data.",
            "**Spatial Context**: While not directly used in classification, the X_in_corr array provides spatial context. If the goal is defect localization or mapping, consider integrating this spatial information into a downstream task (e.g., by treating signal features as image pixels for a 2D CNN)."
        ]
    },
    "plot_paths": [
        "analysis/figures/signal_comparison_mean_median.png",
        "analysis/figures/example_signals.png"
    ]
}